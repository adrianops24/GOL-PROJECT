# üß¨ Conway's Game of Life (Jogo da Vida)

![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=java&logoColor=white) ![Status](https://img.shields.io/badge/Status-Em_Desenvolvimento-green)

Uma implementa√ß√£o em **Java** do famoso aut√¥mato celular criado pelo matem√°tico John Conway em 1970. Este projeto simula a evolu√ß√£o de c√©lulas em uma grade, onde a vida e a morte s√£o determinadas pelas intera√ß√µes com os vizinhos.

## üìã Sobre o Projeto

O "Jogo da Vida" n√£o √© um jogo tradicional: √© um "jogo de zero jogadores". A evolu√ß√£o √© determinada pelo estado inicial e n√£o requer nenhuma entrada adicional. √â um exemplo cl√°ssico para estudar:
* **L√≥gica de Programa√ß√£o e Condicionais Complexas.**
* **Manipula√ß√£o de Matrizes (Arrays Bidimensionais).**
* **Algoritmos de Vizinhan√ßa.**

### üéÆ As Regras
O universo do jogo √© uma grade infinita (neste c√≥digo, limitada por uma matriz $N \times N$) de c√©lulas quadradas. Cada c√©lula tem dois estados: **VIVA** ou **MORTA**.

A cada passo de tempo (gera√ß√£o), as seguintes transi√ß√µes ocorrem:

1.  **Solid√£o:** Qualquer c√©lula viva com menos de 2 vizinhos vivos morre.
2.  **Superpopula√ß√£o:** Qualquer c√©lula viva com mais de 3 vizinhos vivos morre.
3.  **Sobreviv√™ncia:** Qualquer c√©lula viva com 2 ou 3 vizinhos vivos continua viva.
4.  **Reprodu√ß√£o:** Qualquer c√©lula morta com exatamente 3 vizinhos vivos se torna uma c√©lula viva.

---

## üöÄ Como Executar

### Pr√©-requisitos
* Java JDK 8 ou superior instalado.

### Passo a Passo

1.  Clone este reposit√≥rio:
    ```bash
    git clone https://github.com/adrianops24/GOL-PROJECT.git
    ```
2.  Entre na pasta do projeto:
    ```bash
    cd GOL-PROJECT/src
    ```
3.  Compile o c√≥digo:
    ```bash
    javac Main.java
    ```
4.  Execute:
    ```bash
    java Main
    ```

---

## üõ†Ô∏è Estrutura e L√≥gica do C√≥digo

A implementa√ß√£o foca na clareza e efici√™ncia da l√≥gica de matrizes.

### Principais Desafios Resolvidos:

* **Double Buffering (Buffer Duplo):** Um erro comum √© atualizar a matriz *enquanto* se l√™ os vizinhos. Isso causa inconsist√™ncia nos dados.
    * *Solu√ß√£o:* Utilizei duas matrizes: `tabuleiroAtual` (apenas leitura) e `proximaGeracao` (escrita). Ao final de cada loop, o tabuleiro atual recebe os dados da pr√≥xima gera√ß√£o.

* **Verifica√ß√£o de Vizinhos:**
  A l√≥gica percorre as 8 c√©lulas vizinhas (horizontais, verticais e diagonais) utilizando la√ßos aninhados (`for`), garantindo que bordas da matriz n√£o causem erros de `IndexOutOfBounds`.

```java
// Exemplo simplificado da l√≥gica de transi√ß√£o
if (celulaViva && (vizinhos < 2 || vizinhos > 3)) {
    proximaGeracao[i][j] = 0; // Morre
} else if (!celulaViva && vizinhos == 3) {
    proximaGeracao[i][j] = 1; // Nasce
}